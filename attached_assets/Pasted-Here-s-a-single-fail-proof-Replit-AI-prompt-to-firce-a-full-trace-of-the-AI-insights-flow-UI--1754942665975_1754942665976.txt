Here’s a single, **fail‑proof Replit AI prompt** to firce a full trace of the AI‑insights flow (UI → API → jobs → DB), fix three issues, and bakes in tests + verification. 

---

# Replit AI Task — Fix AI‑Insights (context regen, delete persistence, month‑pinning)

## Read This Repo Context First (open these)

* Backend routes + server entry + storage:

  * `server/routes.ts`, any `server/routes/*` files related to insights
  * `server/index.ts`, `server/storage.ts`
* OpenAI integration and background jobs:

  * `server/services/openai.ts`
  * `server/utils/background-processor.ts`
* Schema (tables used here):

  * `shared/schema.ts` → `aiInsights`, `insightContexts`, `metricPrompts`, `globalPromptTemplate`
* Frontend insights UI:

  * `client/src/components/ai-insights.tsx`, `client/src/components/metric-insight-box.tsx`
  * the **Add Context** modal + **Regenerate** button wiring
  * API/query utils (`client/src/lib/queryClient.ts`)

You can use the repo reference, backend map, frontend map, and schema docs to navigate the codebase efficiently. Environment keys for OpenAI live in config/env; assume dev mode (no caching during feature work).

---

## Problems to Reproduce (current behavior)

1. **Add Context doesn’t affect regeneration anymore**

   * Using “Add Context” (modal + **Regenerate** button) creates a record in DB, but the new insight doesn’t reflect it; “With Context” tag used to appear, now it doesn’t.
2. **Delete Insight clears UI only**

   * UI state resets, but the DB row remains. On reload, the old insight reappears.
3. **Persistence across reloads (month‑pinning)**

   * Once an AI insight is generated for `(clientId, metricName, timePeriod)`, it should be reused across page reloads **until** we refresh all data the **following month**. (The refresh trigger will be built later; for now, enforce persistence by month in the read path.)

---

## Acceptance Criteria (must meet all)

* **Add Context → Regenerate**: “Regenerate” must **append** the new user context to existing context and regenerate the insight **using the full accumulated context**. The API response should flag that context was used so the frontend can show **“With Context”**.
* **Delete Insight**: Deleting an insight **removes it from the DB** (hard delete in dev), and subsequent reloads do not resurrect it. No stale cache.
* **Month‑pinned persistence**: If an AI insight exists for `(clientId, metricName, timePeriod=YYYY‑MM)`, the GET read path returns the existing one **without regenerating** until next month’s data refresh lands (you don’t have to implement the month rollover job yet, just the reuse behavior now).
* **No new UI buttons**. Keep the existing modal + Regenerate button behavior.
* **No caching** for this feature path in dev (server + client), or explicitly bypass/disable if present.
* Include **tests** + a **manual verification script** and paste proof in the output.

---

## Flow Map (what to trace before coding)

**UI → API → Background → DB → API → UI**

1. **Add Context**

   * Button opens modal → save context endpoint → shows a **Regenerate** button → pressing regenerate calls the generation endpoint. Confirm actual routes + payloads from code.
   * Expected DB writes: new row in `insightContexts` with `(clientId, metricName, userContext, timestamps)`.
2. **Regenerate**

   * Route should collate all `insightContexts` for `(clientId, metricName)` (append semantics) + system templates (`globalPromptTemplate`, `metricPrompts`) and call OpenAI (or enqueue a job) to produce `aiInsights` for the **current month**.
   * Upsert `aiInsights` for key `(clientId, metricName, timePeriod=YYYY‑MM)` with `{contextText, insightText, recommendationText, status}`.
   * Response must include `usedContext: true` when any user context was applied so the UI can label **With Context**.
3. **Delete**

   * Route should **hard delete** the `aiInsights` row for `(clientId, metricName, timePeriod)` in dev (recommended to avoid stale reads); do **not** delete `insightContexts` (we want the user’s context to remain available for future regenerations).
   * Ensure frontend invalidates the AI‑insights query key and server doesn’t serve stale cache (disable/bypass cache for this path).
4. **Reload**

   * GET path for insights should **return existing aiInsights** if present for the target month; it must **not auto‑regenerate**. Month rollover refresh will be added later.

Citations for flow + schema: repo/route indices and schema tables.

---

## Implement (backend)

1. **Locate insight routes** (search “insight”, “context”, “ai‑insights”) in `server/routes.ts` and any split route files. If missing, create an `aiInsightsRoute.ts` and register it.
2. **Add/confirm endpoints**:

   * `POST /api/ai-insights/:clientId/context`

     * Validate `{ metricName: string, userContext: string }`.
     * **Append behavior**: Insert into `insightContexts` (don’t overwrite). Return `{ ok: true, appended: true }`.
   * `POST /api/ai-insights/:clientId/regenerate`

     * Body: `{ metricName: string, timePeriod?: string }` (default: current month `YYYY‑MM`).
     * Read all `insightContexts` for `(clientId, metricName)` ordered by `createdAt`; concatenate.
     * Load `globalPromptTemplate` + `metricPrompts` for the metric (active versions).
     * Call OpenAI via `server/services/openai.ts` (or enqueue background job and await completion in dev).
     * **Upsert** `aiInsights` for `(clientId, metricName, timePeriod)`.
     * Return `{ ok: true, usedContext: (contexts.length>0), aiInsight }`.
   * `DELETE /api/ai-insights/:clientId`

     * Query params: `metricName`, `timePeriod`.
     * **Hard delete** matching `aiInsights` row (dev). Keep `insightContexts`.
     * Return `{ ok: true, deleted: 1 }`.
3. **Month‑pinned read path**:

   * `GET /api/ai-insights/:clientId?timePeriod=YYYY-MM` returns existing rows from `aiInsights`; do **not** regenerate automatically.
   * If the route previously returned nothing and auto‑regenerated, remove that behavior. We will regenerate only on explicit **POST …/regenerate**.
4. **Caching**:

   * Ensure no server cache for these insights routes (bypass `performance-cache` on these endpoints; verify by code).
5. **Transactions & Idempotency**:

   * Wrap regenerate upsert in a transaction.
   * Use a deterministic unique constraint `(clientId, metricName, timePeriod)` in ORM upsert to avoid duplicates.

---

## Implement (frontend)

1. **Add Context modal**:

   * Confirm it calls `POST /api/ai-insights/:clientId/context` on “Save Context”.
   * Confirm **Regenerate** calls `POST /api/ai-insights/:clientId/regenerate` with `{ metricName, timePeriod }`.
   * After successful regenerate: invalidate `useQuery(["/api/ai-insights", clientId, timePeriod])` and update local state to show the new insight with **With Context** tag.
2. **Delete insight**:

   * Confirm Delete calls `DELETE /api/ai-insights/:clientId?metricName=...&timePeriod=...`.
   * On success, invalidate the same query key and clear local state.
3. **Reload persistence**:

   * On dashboard load, issue `useQuery(["/api/ai-insights", clientId, timePeriod])` and render the stored insight if present (no auto‑regen).

---

## Tests & Verification

### Unit/Integration (backend)

* **Append context**: after two `POST …/context`, `insightContexts` has 2 rows; `POST …/regenerate` concatenates both into prompt; response `usedContext: true`.
* **Upsert by month**: calling `…/regenerate` twice for same `(clientId, metricName, YYYY‑MM)` updates a **single** `aiInsights` row (no duplicates).
* **Delete**: `DELETE …` removes the `aiInsights` row; `insightContexts` remain intact.
* **Read path**: `GET …?timePeriod=YYYY‑MM` returns stored insight and never triggers generation.

### Frontend (manual)

1. Load dashboard → **Add Context** → **Regenerate** → see **With Context** tag.
2. Refresh page → insight persists unchanged.
3. **Delete Insight** → UI clears; reload → still absent.
4. Add context again → Regenerate → insight returns with **With Context**.

### Logging (dev)

* Log context count included in regenerate: `INSIGHT CONTEXT COUNT = N`.
* Log upsert target key: `{clientId, metricName, timePeriod}`.
* Log delete target key and affected rows.

---

## Guardrails & Notes

* Use **append** semantics for context (never destructive).
* Keep `insightContexts` when deleting `aiInsights`. Users expect their added context to be reusable.
* Do **not** introduce new UI controls; wire existing modal/buttons only.
* Keep feature dev with **no caching**; verify server routes do not use performance cache.
* Keep insights **pinned by month** (use `YYYY‑MM` in `aiInsights.timePeriod`).

---

## Deliverables

* Diffs for routes (add/confirm 3 endpoints), OpenAI service integration, storage calls, and frontend mutations/invalidations.
* Test code or scripts (backend) + a short **verification log** (include sample cURL calls + JSON outputs).
* Brief **root‑cause note** (why context wasn’t used, why delete didn’t clear DB, why reload re‑generated or repainted).

---

### Repo anchors you can cite while working

* API route registry and dashboard/insights indexes
* Frontend insights components + query usage
* Schema for `aiInsights`, `insightContexts`, `metricPrompts`, `globalPromptTemplate`
* Background processor & enqueue pattern (AI\_INSIGHT jobs)
* Env keys for OpenAI model/key (dev)

---

If any existing endpoints differ from these names, **do not invent new ones**—adapt the implementation to the actual routes/components and note the diffs in your output.