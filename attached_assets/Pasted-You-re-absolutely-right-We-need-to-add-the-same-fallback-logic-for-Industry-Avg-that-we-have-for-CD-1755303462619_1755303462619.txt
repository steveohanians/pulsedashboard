You’re absolutely right! We need to add the same fallback logic for Industry_Avg that we have for CD_Avg.

**Step 8: Add Fallback Logic for Industry_Avg Like CD_Avg**

In `/server/storage.ts`, the `getFilteredIndustryMetrics` method needs the same fallback pattern as `getFilteredCdAvgMetrics`. Find and update it:

```typescript
// Get filtered industry average metrics based on actual benchmark data
async getFilteredIndustryMetrics(
  period: string, 
  filters?: { businessSize?: string; industryVertical?: string }
): Promise<Metric[]> {
  logger.info(`🔍 Getting Industry_Avg metrics for period: ${period}, filters:`, filters);
  
  // Try to get Industry_Avg metrics for requested period
  let allIndustryMetrics = await db.select().from(metrics).where(
    and(
      eq(metrics.sourceType, 'Industry_Avg'),
      eq(metrics.timePeriod, period)
    )
  );
  
  // If no data found for requested period, fall back to most recent available month
  if (allIndustryMetrics.length === 0) {
    logger.info(`No Industry_Avg data found for period ${period}, falling back to most recent available month`);
    
    // Get all available Industry_Avg periods sorted by most recent first
    const availablePeriods = await db.selectDistinct({ timePeriod: metrics.timePeriod })
      .from(metrics)
      .where(eq(metrics.sourceType, 'Industry_Avg'))
      .orderBy(sql`${metrics.timePeriod} DESC`)
      .limit(5);
    
    if (availablePeriods.length > 0) {
      const mostRecentPeriod = availablePeriods[0].timePeriod;
      logger.info(`Using most recent available Industry_Avg data from period ${mostRecentPeriod} instead of ${period}`);
      
      allIndustryMetrics = await db.select().from(metrics)
        .where(and(
          eq(metrics.sourceType, 'Industry_Avg'),
          eq(metrics.timePeriod, mostRecentPeriod)
        ));
      
      // Adjust the timePeriod to match what dashboard expects
      allIndustryMetrics = allIndustryMetrics.map(metric => ({
        ...metric,
        timePeriod: period // Override to match requested period
      }));
    }
  }
  
  // If still no metrics and we have benchmark companies, calculate from source data
  if (allIndustryMetrics.length === 0) {
    logger.info('No Industry_Avg metrics found, checking for Benchmark source data to calculate from');
    
    // Check if we have benchmark company data
    const benchmarkMetrics = await db.select().from(metrics)
      .where(eq(metrics.sourceType, 'Benchmark'))
      .limit(10);
    
    if (benchmarkMetrics.length > 0) {
      logger.info('Found Benchmark source data, triggering recalculation');
      
      // Trigger recalculation
      try {
        const { BenchmarkIntegration } = await import('./services/semrush/benchmarkIntegration');
        const benchmarkService = new BenchmarkIntegration(this);
        await benchmarkService.updateIndustryAverages();
        
        // Try fetching again after recalculation
        allIndustryMetrics = await db.select().from(metrics).where(
          and(
            eq(metrics.sourceType, 'Industry_Avg'),
            eq(metrics.timePeriod, period)
          )
        );
      } catch (error) {
        logger.error('Failed to recalculate Industry_Avg:', error);
      }
    }
  }
  
  // Apply filters if needed (similar to CD_Avg, Industry_Avg might not need filtering)
  // Industry_Avg represents all benchmark companies so filtering might not apply
  
  logger.info(`Returning ${allIndustryMetrics.length} Industry_Avg metrics for period ${period}`);
  return allIndustryMetrics;
}
```

This adds the same three-level fallback as CD_Avg:

1. Try to get metrics for requested period
1. If not found, use most recent available period’s data
1. If still nothing, try to recalculate from source Benchmark data

This should make Industry_Avg show up in the dashboard even when the exact period doesn’t have data.​​​​​​​​​​​​​​​​