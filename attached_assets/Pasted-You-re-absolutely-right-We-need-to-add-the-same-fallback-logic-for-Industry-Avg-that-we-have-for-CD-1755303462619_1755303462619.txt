Youâ€™re absolutely right! We need to add the same fallback logic for Industry_Avg that we have for CD_Avg.

**Step 8: Add Fallback Logic for Industry_Avg Like CD_Avg**

In `/server/storage.ts`, the `getFilteredIndustryMetrics` method needs the same fallback pattern as `getFilteredCdAvgMetrics`. Find and update it:

```typescript
// Get filtered industry average metrics based on actual benchmark data
async getFilteredIndustryMetrics(
  period: string, 
  filters?: { businessSize?: string; industryVertical?: string }
): Promise<Metric[]> {
  logger.info(`ðŸ” Getting Industry_Avg metrics for period: ${period}, filters:`, filters);
  
  // Try to get Industry_Avg metrics for requested period
  let allIndustryMetrics = await db.select().from(metrics).where(
    and(
      eq(metrics.sourceType, 'Industry_Avg'),
      eq(metrics.timePeriod, period)
    )
  );
  
  // If no data found for requested period, fall back to most recent available month
  if (allIndustryMetrics.length === 0) {
    logger.info(`No Industry_Avg data found for period ${period}, falling back to most recent available month`);
    
    // Get all available Industry_Avg periods sorted by most recent first
    const availablePeriods = await db.selectDistinct({ timePeriod: metrics.timePeriod })
      .from(metrics)
      .where(eq(metrics.sourceType, 'Industry_Avg'))
      .orderBy(sql`${metrics.timePeriod} DESC`)
      .limit(5);
    
    if (availablePeriods.length > 0) {
      const mostRecentPeriod = availablePeriods[0].timePeriod;
      logger.info(`Using most recent available Industry_Avg data from period ${mostRecentPeriod} instead of ${period}`);
      
      allIndustryMetrics = await db.select().from(metrics)
        .where(and(
          eq(metrics.sourceType, 'Industry_Avg'),
          eq(metrics.timePeriod, mostRecentPeriod)
        ));
      
      // Adjust the timePeriod to match what dashboard expects
      allIndustryMetrics = allIndustryMetrics.map(metric => ({
        ...metric,
        timePeriod: period // Override to match requested period
      }));
    }
  }
  
  // If still no metrics and we have benchmark companies, calculate from source data
  if (allIndustryMetrics.length === 0) {
    logger.info('No Industry_Avg metrics found, checking for Benchmark source data to calculate from');
    
    // Check if we have benchmark company data
    const benchmarkMetrics = await db.select().from(metrics)
      .where(eq(metrics.sourceType, 'Benchmark'))
      .limit(10);
    
    if (benchmarkMetrics.length > 0) {
      logger.info('Found Benchmark source data, triggering recalculation');
      
      // Trigger recalculation
      try {
        const { BenchmarkIntegration } = await import('./services/semrush/benchmarkIntegration');
        const benchmarkService = new BenchmarkIntegration(this);
        await benchmarkService.updateIndustryAverages();
        
        // Try fetching again after recalculation
        allIndustryMetrics = await db.select().from(metrics).where(
          and(
            eq(metrics.sourceType, 'Industry_Avg'),
            eq(metrics.timePeriod, period)
          )
        );
      } catch (error) {
        logger.error('Failed to recalculate Industry_Avg:', error);
      }
    }
  }
  
  // Apply filters if needed (similar to CD_Avg, Industry_Avg might not need filtering)
  // Industry_Avg represents all benchmark companies so filtering might not apply
  
  logger.info(`Returning ${allIndustryMetrics.length} Industry_Avg metrics for period ${period}`);
  return allIndustryMetrics;
}
```

This adds the same three-level fallback as CD_Avg:

1. Try to get metrics for requested period
1. If not found, use most recent available periodâ€™s data
1. If still nothing, try to recalculate from source Benchmark data

This should make Industry_Avg show up in the dashboard even when the exact period doesnâ€™t have data.â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹