You are editing the Pulse Dashboard frontend.

File to edit: client/src/components/metric-insight-box.tsx 

Goals:
1) DELETE should immediately show the empty state (no flash-back to old text), then stay empty until refetch completes.
2) Typewriter should reliably animate whenever a new server insightText arrives.

Make ALL of the following changes:

A) Add two refs at the top of the component (near other refs/state):
-------------------------------------------------------------------
const suppressHydrationRef = useRef(false); // if not already present
const lastTypedRef = useRef<string>("");    // track last fully-typed server text

B) Fix DELETE: optimistic clear + cache surgery + suppression
------------------------------------------------------------
In the delete handler (the one calling /api/ai-insights/:clientId/:metricName?period=...):

1) BEFORE firing the mutation/fetch:
   suppressHydrationRef.current = true;
   // Optimistically clear local UI to the empty state
   setInsight(null);

2) Immediately remove the metric from the React Query cache so hydration cannot reinsert it:
   queryClient.setQueryData(
     ["/api/ai-insights", clientId, canonicalPeriod],
     (prev: any) => {
       if (!prev || !Array.isArray(prev.insights)) return prev;
       return { ...prev, insights: prev.insights.filter((it: any) => it.metricName !== metricName) };
     }
   );

3) After the delete request resolves, do BOTH invalidate and refetch of the insights list:
   await queryClient.invalidateQueries({ queryKey: ["/api/ai-insights", clientId, canonicalPeriod] });
   await queryClient.refetchQueries({ queryKey: ["/api/ai-insights", clientId, canonicalPeriod], type: "active" });

4) Finally, allow hydration again:
   suppressHydrationRef.current = false;

(Keep your existing context invalidation for this metric, if any.)

C) Guard the hydration-from-server effect
-----------------------------------------
In the effect that sets local `insight` from `metricInsight`, add these early returns:

   if (suppressHydrationRef.current) return;    // don’t hydrate while we’re mutating
   if (insight?.isTyping) return;               // don’t overwrite while typewriter is running

Then proceed with your normal setInsight from `metricInsight` (including server `hasContext`).

D) Robust typewriter trigger (works even if status wording differs)
-------------------------------------------------------------------
1) Add a helper (inside the component):
   function runTypewriter(full: string, setter: (s: string) => void) {
     clearInterval((runTypewriter as any)._id);
     setter("");
     let i = 0;
     (runTypewriter as any)._id = setInterval(() => {
       i++;
       setter(full.slice(0, i));
       if (i >= full.length) clearInterval((runTypewriter as any)._id);
     }, 12);
   }

2) Add a new effect that starts typing whenever the **server** delivers a NEW `insightText`:
   useEffect(() => {
     if (suppressHydrationRef.current) return;
     const serverText = (metricInsight?.insightText || "").trim();
     if (!serverText) return;

     // Only run when text truly changed (prevents loops)
     if (serverText === lastTypedRef.current) return;

     // Start typewriter
     setInsight(cur => cur ? { ...cur, isTyping: true } : { isTyping: true } as any);
     runTypewriter(serverText, t =>
       setInsight(cur => cur ? { ...cur, insightText: t } : { insightText: t } as any)
     );

     // Mark this version as typed and schedule isTyping=false at the end
     lastTypedRef.current = serverText;
     const ms = Math.max(200, (serverText.length + 2) * 12);
     const done = setTimeout(() => {
       setInsight(cur => cur ? { ...cur, isTyping: false } : { isTyping: false } as any);
     }, ms);
     return () => clearTimeout(done);
   }, [metricInsight?.insightText]);

Notes:
- This trigger keys only on `metricInsight.insightText` changing, so it works whether status is "available", "ready", etc.
- Hydration effect won’t fight typing because of the `isTyping` and `suppressHydrationRef` guards.

E) Keep the regenerate fixes you already added:
----------------------------------------------
- Set `suppressHydrationRef.current = true` before mutations and flip it OFF in onSettled.
- In onSuccess, invalidate + refetch the same list key: ["/api/ai-insights", clientId, canonicalPeriod].
- For regenerate-with-context, keep the optimistic `{ hasContext: true, isTyping: true }`.

Deliverable:
- After DELETE: the box stays empty immediately (no flash-back) and remains so until refetch.
- After REGENERATE: old text does not reappear; once the server returns new text, it animates with the typewriter.