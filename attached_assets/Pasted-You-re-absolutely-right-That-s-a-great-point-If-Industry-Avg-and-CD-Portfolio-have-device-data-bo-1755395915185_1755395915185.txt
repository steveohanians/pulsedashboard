You're absolutely right! That's a great point. If Industry_Avg and CD Portfolio have device data (both coming from SEMrush), then competitors should ALSO have device data from SEMrush. They're all using the same data source!

Let me investigate why competitor device data isn't showing up. The issue is likely in how we're looking for it, not that it doesn't exist.

# Step 7 (CORRECTLY): Find the Real Competitor Device Data

**INSTRUCTION FOR REPLIT:**
The competitor device data MUST exist since it comes from the same SEMrush source as CD Portfolio and Industry_Avg. Let's find where it actually is in the data structure.

**MODIFY `/client/src/services/unifiedDataService.ts` - UPDATE THE COMPETITOR PROCESSING WITH BETTER DATA DISCOVERY:**

```typescript
    // Process Competitors - FIND THE REAL DATA
    // Competitors use SEMrush just like CD_Avg and Industry_Avg, so data MUST exist
    competitors.forEach((competitor) => {
      let devices: any[] = [];
      let dataFound = false;
      
      // Check 1: Look in metrics with competitorId
      const competitorMetrics = deviceMetrics.filter(m => 
        m.sourceType === "Competitor" && 
        m.competitorId === competitor.id
      );
      
      if (competitorMetrics.length > 0) {
        devices = this.aggregateDevicesBySource(competitorMetrics);
        if (devices.length > 0) {
          dataFound = true;
          debugLog('UNIFIED', `Found device data for competitor ${competitor.domain} in metrics`, { devices });
        }
      }
      
      // Check 2: Look for metrics with channel field containing numeric device types
      if (!dataFound) {
        // Competitor data might use numeric channels like Industry_Avg
        const numericDeviceMetrics = metrics.filter(m => 
          m.metricName === "Device Distribution" &&
          m.sourceType === "Competitor" &&
          m.competitorId === competitor.id &&
          m.channel !== undefined
        );
        
        if (numericDeviceMetrics.length > 0) {
          const deviceMap = new Map<string, number>();
          
          numericDeviceMetrics.forEach(metric => {
            // Convert numeric channel to device name
            const deviceName = metric.channel === '0' ? 'Desktop' : 
                             metric.channel === '1' ? 'Mobile' : 
                             metric.channel;
            const value = parseFloat(String(metric.value));
            
            if (deviceName && !isNaN(value)) {
              deviceMap.set(deviceName, (deviceMap.get(deviceName) || 0) + value);
            }
          });
          
          deviceMap.forEach((value, name) => {
            devices.push({
              name,
              value: Math.round(value * 10) / 10,
              percentage: Math.round(value * 10) / 10,
              color: this.getDeviceColor(name)
            });
          });
          
          if (devices.length > 0) {
            dataFound = true;
            debugLog('UNIFIED', `Found device data for competitor ${competitor.domain} using numeric channels`, { devices });
          }
        }
      }
      
      // Check 3: Look in averagedMetrics if available
      if (!dataFound && averagedMetrics) {
        // Check if competitor data is in averagedMetrics under a different structure
        const possibleKeys = [
          `Competitor_${competitor.id}`,
          `competitor_${competitor.id}`,
          competitor.domain,
          competitor.id
        ];
        
        for (const key of possibleKeys) {
          if (averagedMetrics["Device Distribution"] && averagedMetrics["Device Distribution"][key]) {
            const competitorData = averagedMetrics["Device Distribution"][key];
            devices = this.parseDeviceValue(competitorData);
            if (devices.length > 0) {
              dataFound = true;
              debugLog('UNIFIED', `Found device data for competitor ${competitor.domain} in averagedMetrics`, { key, devices });
              break;
            }
          }
        }
      }
      
      // Only add to result if we found real data
      if (dataFound && devices.length > 0) {
        // Normalize percentages to ensure they add to 100
        const total = devices.reduce((sum, d) => sum + d.value, 0);
        if (total > 0 && Math.abs(total - 100) > 1) {
          devices.forEach(device => {
            device.value = Math.round((device.value / total) * 1000) / 10;
            device.percentage = device.value;
          });
        }
        
        result.push({
          sourceType: `Competitor_${competitor.id}`,
          label: this.cleanDomainName(competitor.domain),
          devices: devices
        });
      } else {
        // Log that we couldn't find data - this helps debugging
        debugLog('UNIFIED', `WARNING: No device data found for competitor ${competitor.domain}`, {
          competitorId: competitor.id,
          checkedMetricsCount: competitorMetrics.length,
          availableSourceTypes: Array.from(new Set(deviceMetrics.map(m => m.sourceType)))
        });
      }
    });
```

This approach:
1. Checks for competitor device data in regular metrics format
2. Checks for numeric channel format (like Industry_Avg uses '0' and '1')
3. Checks in averagedMetrics under various possible keys
4. Only shows competitors that have real data
5. Logs warnings when data can't be found to help debug

The competitor device data SHOULD exist somewhere since they're from SEMrush just like CD_Avg and Industry_Avg. This will help us find it.