there should already be a fallback mechanism. Let's debug why the fallback isn't working for Industry_Avg in Last Month view.
Copy this debug endpoint into your routes.ts file:
typescript// Debug why Industry_Avg fallback isn't working for Last Month
app.get('/api/debug/industry-avg-fallback', requireAuth, async (req, res) => {
  try {
    const { db } = await import('./db');
    const { metrics } = await import('@shared/schema');
    const { eq, and, inArray, desc, sql } = await import('drizzle-orm');
    
    // What period is "Last Month" (July 2025 for GA4)
    const now = new Date();
    const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const ga4Period = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`; // 2025-07
    
    // SEMrush is one month behind (June 2025)
    const semrushMonth = new Date(now.getFullYear(), now.getMonth() - 2, 1);
    const semrushPeriod = `${semrushMonth.getFullYear()}-${String(semrushMonth.getMonth() + 1).padStart(2, '0')}`; // 2025-06
    
    // Get Industry_Avg for both periods
    const industryAvgData = await db
      .select({
        metricName: metrics.metricName,
        timePeriod: metrics.timePeriod,
        value: metrics.value,
        sourceType: metrics.sourceType
      })
      .from(metrics)
      .where(
        and(
          eq(metrics.sourceType, 'Industry_Avg'),
          inArray(metrics.timePeriod, [ga4Period, semrushPeriod, '2025-06', '2025-07'])
        )
      )
      .orderBy(metrics.metricName, desc(metrics.timePeriod));
    
    // Get CD_Avg for comparison (to see if fallback works there)
    const cdAvgData = await db
      .select({
        metricName: metrics.metricName,
        timePeriod: metrics.timePeriod,
        value: metrics.value,
        sourceType: metrics.sourceType
      })
      .from(metrics)
      .where(
        and(
          eq(metrics.sourceType, 'CD_Avg'),
          inArray(metrics.timePeriod, [ga4Period, semrushPeriod, '2025-06', '2025-07'])
        )
      )
      .orderBy(metrics.metricName, desc(metrics.timePeriod));
    
    // Group by metric to see what periods have data
    const coreMetrics = ['Bounce Rate', 'Session Duration', 'Pages per Session', 'Sessions per User'];
    
    const analysis = coreMetrics.map(metricName => {
      const industryData = industryAvgData.filter(m => m.metricName === metricName);
      const cdData = cdAvgData.filter(m => m.metricName === metricName);
      
      return {
        metric: metricName,
        industry_avg: {
          has_july_2025: industryData.some(d => d.timePeriod === '2025-07'),
          has_june_2025: industryData.some(d => d.timePeriod === '2025-06'),
          periods_available: industryData.map(d => d.timePeriod),
          should_fallback: !industryData.some(d => d.timePeriod === '2025-07') && industryData.some(d => d.timePeriod === '2025-06')
        },
        cd_avg: {
          has_july_2025: cdData.some(d => d.timePeriod === '2025-07'),
          has_june_2025: cdData.some(d => d.timePeriod === '2025-06'),
          periods_available: cdData.map(d => d.timePeriod),
          fallback_working: !cdData.some(d => d.timePeriod === '2025-07') && cdData.some(d => d.timePeriod === '2025-06')
        }
      };
    });
    
    // Check Traffic Channels specifically
    const trafficChannels = await db
      .select({
        sourceType: metrics.sourceType,
        timePeriod: metrics.timePeriod,
        channel: metrics.channel,
        value: metrics.value
      })
      .from(metrics)
      .where(
        and(
          eq(metrics.metricName, 'Traffic Channels'),
          inArray(metrics.sourceType, ['Industry_Avg', 'CD_Avg']),
          inArray(metrics.timePeriod, [ga4Period, semrushPeriod])
        )
      );
    
    res.json({
      periods: {
        ga4_target: ga4Period,
        semrush_fallback: semrushPeriod,
        current_month: now.toISOString().slice(0, 7)
      },
      core_metrics_analysis: analysis,
      fallback_diagnosis: {
        industry_avg_broken: analysis.filter(a => a.industry_avg.should_fallback && !a.industry_avg.has_july_2025),
        cd_avg_working: analysis.filter(a => a.cd_avg.fallback_working)
      },
      traffic_channels: {
        data_found: trafficChannels.length,
        by_source_and_period: trafficChannels.reduce((acc, tc) => {
          const key = `${tc.sourceType}_${tc.timePeriod}`;
          if (!acc[key]) acc[key] = [];
          acc[key].push({ channel: tc.channel, value: tc.value });
          return acc;
        }, {} as any)
      },
      recommendation: analysis.some(a => a.industry_avg.has_june_2025 && !a.industry_avg.has_july_2025) ?
        'Industry_Avg has June data but not July. Fallback mechanism may be broken. Need to copy June data to July period.' :
        'Check if benchmark companies have been added and SEMrush integration has run.'
    });
    
  } catch (error) {
    console.error('Fallback debug error:', error);
    res.status(500).json({ 
      error: error instanceof Error ? error.message : 'Debug failed'
    });
  }
});
Run this endpoint and share the response:
/api/debug/industry-avg-fallback
This will show us:

Whether Industry_Avg has June (2025-06) data that should be used as fallback
Whether CD_Avg fallback is working (for comparison)
What's happening with Traffic Channels
Specific recommendation for the fix