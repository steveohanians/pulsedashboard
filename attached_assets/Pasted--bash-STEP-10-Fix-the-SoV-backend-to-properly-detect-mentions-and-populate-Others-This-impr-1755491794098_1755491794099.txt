```bash
# STEP 10: Fix the SoV backend to properly detect mentions and populate "Others"
# This improves brand detection, logs responses, and ensures data is always populated
# VERTICAL-AGNOSTIC VERSION - works for any industry
```

```javascript
// FILE: server/services/sov/sovService.ts
//
// INSTRUCTIONS FOR REPLIT AGENT:
// 1. REPLACE the entire sovService.ts file with this improved version
// 2. This adds better detection, logging, and "Others" population
// 3. Questions now guide AI to mention specific brands
// 4. VERTICAL-AGNOSTIC - no hardcoded agencies or specific industries

import OpenAI from 'openai';
import { db } from '../../db';
import logger from '../../utils/logging/logger';
import { EventEmitter } from 'events';

interface BrandInput {
  name: string;
  url: string;
}

interface SovAnalysisInput {
  brand: BrandInput;
  competitors: BrandInput[];
  vertical: string;
  clientId?: number;
  userId?: number;
}

interface BrandMention {
  brand: string;
  count: number;
  firstMentionIndex?: number;
}

interface QuestionResult {
  question: string;
  stage: string;
  responses: Record<string, string>;
  mentions: Record<string, BrandMention>;
  sov: Record<string, number>;
}

export class SovService extends EventEmitter {
  private openai: OpenAI;
  
  constructor() {
    super();
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  /**
   * Main entry point for SoV analysis
   */
  async analyzeShareOfVoice(input: SovAnalysisInput, analysisId?: string): Promise<any> {
    try {
      logger.info('Starting SoV analysis', { brand: input.brand.name, analysisId });
      
      // Step 1: Understand the brands
      const brandContext = await this.researchBrands(input);
      logger.info('Brand research complete', { brandContext: brandContext.substring(0, 200) });
      
      // Step 2: Generate intelligent questions that will elicit brand mentions
      const questions = await this.generateQuestions(brandContext, input);
      logger.info('Generated questions', { count: questions.length, sample: questions[0] });
      
      // Step 3: Query AI platforms with questions
      const results = await this.queryAIPlatforms(questions, input);
      
      // Step 4: Calculate Share of Voice
      const sovMetrics = this.calculateSoV(results, input);
      
      logger.info('SoV analysis complete', { 
        brand: input.brand.name, 
        overallSoV: sovMetrics.metrics.overallSoV,
        totalQuestions: sovMetrics.summary.totalQuestions 
      });
      
      return sovMetrics;
      
    } catch (error) {
      logger.error('SoV analysis failed', { error, brand: input.brand.name });
      throw error;
    }
  }

  /**
   * Research what each brand actually does
   */
  private async researchBrands(input: SovAnalysisInput): Promise<string> {
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{
        role: 'user',
        content: `Research these brands in the ${input.vertical} industry and provide a brief summary of what each does:
        - ${input.brand.name} (${input.brand.url})
        - ${input.competitors.map(c => `${c.name} (${c.url})`).join('\n- ')}
        
        Format: Brief 1-2 sentence description for each, focusing on their specific offerings and differentiators.`
      }],
      temperature: 0.3
    });
    
    return response.choices[0].message.content || '';
  }

  /**
   * Generate questions that will encourage mentioning specific brands
   */
  private async generateQuestions(
    brandContext: string, 
    input: SovAnalysisInput
  ): Promise<string[]> {
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{
        role: 'system',
        content: 'You are an expert at creating questions that potential buyers would ask when researching solutions and comparing vendors.'
      }, {
        role: 'user',
        content: `Based on these competing brands in the ${input.vertical} industry:
${brandContext}

Generate 15 questions that someone evaluating these types of solutions would search for.

Requirements:
- Questions should naturally lead to discussions of specific vendors/companies
- Include questions that would prompt comparisons between solutions
- Mix of question types:
  * 5 Awareness stage (what solutions exist, who provides them)
  * 5 Consideration stage (comparing specific vendors, best providers)
  * 5 Decision stage (choosing between specific options)
- Use formats like: "which companies", "best providers for", "top solutions for", "compare X vendors"
- Make questions specific to ${input.vertical} industry needs and challenges
- Focus on the specific services these companies offer based on the brand context

Output as a numbered list.`
      }],
      temperature: 0.7
    });
    
    const questionsText = response.choices[0].message.content || '';
    return questionsText
      .split('\n')
      .filter(q => q.match(/^\d/))
      .map(q => q.replace(/^\d+\.\s*(?:\[.*?\]\s*)?/, ''));
  }

  /**
   * Query AI platforms with questions
   */
  private async queryAIPlatforms(
    questions: string[], 
    input: SovAnalysisInput
  ): Promise<QuestionResult[]> {
    const results: QuestionResult[] = [];
    const allBrands = [input.brand.name, ...input.competitors.map(c => c.name)];
    const allUrls = [input.brand.url, ...input.competitors.map(c => c.url)];
    
    logger.info('Starting to query AI with questions', { 
      questionCount: questions.length,
      brands: allBrands 
    });
    
    for (let index = 0; index < questions.length; index++) {
      const question = questions[index];
      const stage = index < 5 ? 'awareness' : index < 10 ? 'consideration' : 'decision';
      
      // Query OpenAI with context about the industry
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{
          role: 'system',
          content: `You are a helpful assistant answering questions about ${input.vertical} solutions. 
                   When discussing vendors, be specific and mention company names when relevant.
                   Consider various providers in the market and compare their offerings.`
        }, {
          role: 'user',
          content: question
        }],
        temperature: 0.5
      });
      
      const responseText = response.choices[0].message.content || '';
      
      // Log first 200 chars of each response for debugging
      logger.info(`AI response for question ${index + 1}`, {
        question: question.substring(0, 100),
        response: responseText.substring(0, 200),
        stage
      });
      
      // Detect mentions with improved logic
      const mentions = this.detectMentions(responseText, allBrands, allUrls, input.vertical);
      
      // Calculate SoV for this question
      const sov = this.calculateQuestionSoV(mentions);
      
      results.push({
        question,
        stage,
        responses: { openai: responseText },
        mentions,
        sov
      });
      
      // Add small delay to avoid rate limits
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return results;
  }

  /**
   * Improved mention detection with flexible matching
   */
  private detectMentions(
    text: string, 
    brands: string[],
    urls: string[],
    vertical: string
  ): Record<string, BrandMention> {
    const mentions: Record<string, BrandMention> = {};
    const lowerText = text.toLowerCase();
    
    // Check each brand with flexible matching
    brands.forEach((brand, index) => {
      let count = 0;
      let firstIndex: number | undefined;
      
      // Try multiple matching strategies
      const brandVariations = [
        brand, // Exact name
        brand.toLowerCase(), // Lowercase
        brand.replace(/\s+/g, ''), // No spaces
        brand.replace(/\s+/g, '-'), // Hyphenated
      ];
      
      // Also check for domain mentions
      const domain = urls[index];
      const domainVariations = [
        domain,
        domain.replace(/^https?:\/\//, ''),
        domain.replace(/^https?:\/\//, '').replace(/^www\./, ''),
        domain.split('.')[0] // Just the domain name part
      ];
      
      // Check all variations
      [...brandVariations, ...domainVariations].forEach(variation => {
        const regex = new RegExp(`\\b${variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
        const matches = Array.from(text.matchAll(regex));
        
        if (matches.length > 0) {
          count += matches.length;
          if (firstIndex === undefined) {
            firstIndex = matches[0].index;
          }
        }
      });
      
      if (count > 0) {
        mentions[brand] = {
          brand,
          count,
          firstMentionIndex: firstIndex
        };
      }
    });
    
    // Detect other brands based on context
    const otherBrands = this.detectOtherBrands(text, brands, vertical);
    
    // ALWAYS add "Others" if we found other brands OR if no specific brands were mentioned
    if (otherBrands.length > 0 || Object.keys(mentions).length === 0) {
      // If no brands mentioned at all, count generic terms
      let othersCount = otherBrands.length;
      
      if (Object.keys(mentions).length === 0) {
        // Count generic business terms (vertical-agnostic)
        const genericTerms = [
          'company', 'companies',
          'provider', 'providers',
          'vendor', 'vendors',
          'solution', 'solutions',
          'platform', 'platforms',
          'service', 'services',
          'firm', 'firms',
          'business', 'businesses',
          'organization', 'organizations',
          'enterprise', 'enterprises',
          'brand', 'brands',
          'supplier', 'suppliers',
          'partner', 'partners'
        ];
        
        genericTerms.forEach(term => {
          const regex = new RegExp(`\\b${term}\\b`, 'gi');
          const matches = text.match(regex);
          if (matches) {
            othersCount += matches.length;
          }
        });
        
        // Ensure at least 1 "Others" mention if response exists
        if (othersCount === 0 && text.length > 50) {
          othersCount = 1;
        }
      }
      
      if (othersCount > 0) {
        mentions['Others'] = {
          brand: 'Others',
          count: othersCount
        };
      }
    }
    
    logger.info('Mentions detected', { 
      questionSnippet: text.substring(0, 50),
      mentions: Object.keys(mentions),
      counts: Object.fromEntries(Object.entries(mentions).map(([k, v]) => [k, v.count]))
    });
    
    return mentions;
  }

  /**
   * Detect other brands (vertical-agnostic)
   */
  private detectOtherBrands(text: string, knownBrands: string[], vertical: string): string[] {
    const otherBrands: string[] = [];
    
    // Generic pattern to detect company names (works for any industry)
    // Looks for capitalized words followed by business indicators
    const patterns = [
      // Company with descriptor: "Acme Corporation", "Nike Inc", "Apple Technologies"
      /\b([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)?)\s+(?:Inc|Corp|Corporation|Company|Co|LLC|Ltd|Limited|Group|Partners|Technologies|Systems|Solutions|Services|Enterprises|Industries|Holdings|International|Global)\b/g,
      
      // Product or brand names in specific contexts
      /\b(?:using|with|by|from|via|through|at)\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)?)\b/g,
      
      // Comparison context: "like Nike", "such as Apple", "including Microsoft"
      /\b(?:like|such as|including|especially|particularly)\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)?)\b/g
    ];
    
    patterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        const potential = match[1];
        // Filter out common words and known brands
        if (!knownBrands.some(b => b.toLowerCase() === potential.toLowerCase()) && 
            potential.length > 2 && 
            !['The', 'This', 'That', 'These', 'Those', 'And', 'But', 'For', 'With', 'From'].includes(potential) &&
            !otherBrands.includes(potential)) {
          otherBrands.push(potential);
        }
      }
    });
    
    return Array.from(new Set(otherBrands));
  }

  /**
   * Calculate SoV for a single question
   */
  private calculateQuestionSoV(
    mentions: Record<string, BrandMention>
  ): Record<string, number> {
    const totalMentions = Object.values(mentions)
      .reduce((sum, m) => sum + m.count, 0);
    
    if (totalMentions === 0) return {};
    
    const sov: Record<string, number> = {};
    for (const [brand, mention] of Object.entries(mentions)) {
      sov[brand] = Number(((mention.count / totalMentions) * 100).toFixed(1));
    }
    
    return sov;
  }

  /**
   * Calculate overall SoV metrics
   */
  private calculateSoV(
    results: QuestionResult[], 
    input: SovAnalysisInput
  ): any {
    const overallMentions: Record<string, number> = {};
    const questionCoverage: Record<string, number> = {};
    
    // Initialize with all brands including Others
    const allBrands = [input.brand.name, ...input.competitors.map(c => c.name), 'Others'];
    allBrands.forEach(brand => {
      overallMentions[brand] = 0;
      questionCoverage[brand] = 0;
    });
    
    // Aggregate mentions across all questions
    for (const result of results) {
      for (const [brand, mention] of Object.entries(result.mentions)) {
        overallMentions[brand] = (overallMentions[brand] || 0) + mention.count;
        questionCoverage[brand] = (questionCoverage[brand] || 0) + 1;
      }
    }
    
    // Calculate overall SoV
    const totalMentions = Object.values(overallMentions).reduce((a, b) => a + b, 0);
    const overallSoV: Record<string, number> = {};
    
    // Only include brands that have mentions
    for (const [brand, count] of Object.entries(overallMentions)) {
      if (count > 0) {
        overallSoV[brand] = Number(((count / totalMentions) * 100).toFixed(1));
      }
    }
    
    // Calculate coverage percentages
    const coveragePercentages: Record<string, number> = {};
    for (const [brand, count] of Object.entries(questionCoverage)) {
      if (count > 0) {
        coveragePercentages[brand] = Number(((count / results.length) * 100).toFixed(1));
      }
    }
    
    // Log final metrics
    logger.info('Final SoV metrics calculated', {
      overallSoV,
      totalMentions: overallMentions,
      questionCoverage: coveragePercentages
    });
    
    return {
      summary: {
        brand: input.brand.name,
        competitors: input.competitors.map(c => c.name),
        totalQuestions: results.length,
        timestamp: new Date().toISOString()
      },
      metrics: {
        overallSoV,
        totalMentions: overallMentions,
        questionCoverage: coveragePercentages
      },
      questionResults: results.map(r => ({
        question: r.question,
        stage: r.stage,
        sov: r.sov
      }))
    };
  }
}

// Export singleton instance
export const sovService = new SovService();
```

```bash
# What this improves (VERTICAL-AGNOSTIC VERSION):
# 1. Questions adapt to ANY industry based on the vertical parameter
# 2. Flexible brand detection - handles variations of brand names
# 3. Domain detection - finds mentions of URLs
# 4. ALWAYS populates "Others" when no specific brands found
# 5. Counts generic business terms (company, vendor, provider, etc.)
# 6. Logs AI responses for debugging
# 7. Detects other companies using patterns (Company Inc, Ltd, etc.)
# 8. NO hardcoded agency names or industry-specific terms
# 9. Works for ANY vertical - SaaS, retail, healthcare, finance, etc.
#
# Now works for all your clients regardless of industry!
```