Repo Context

Frontend Path: client/src/components/metric-insight-box.tsx, client/src/pages/dashboard.tsx

Backend Path: server/routes.ts, server/storage.ts, server/services/aiInsightsService.ts (or equivalent service layer)

Schema: aiInsights and insightContexts tables (see schema_reference_v1.md)

Query Keys: QueryKeys.aiInsights(clientId, canonicalPeriod)

Data Flow:

GET /api/ai-insights/:clientId?period=YYYY-MM → storage.getAIInsightsForPeriod() returns array with computed hasContext

DELETE /api/ai-insights/:clientId/:metricName?period=YYYY-MM → storage.deleteInsightAndContextTransactional() deletes from both tables atomically

Context add/regenerate uses insightContexts row + updated aiInsights row for the same (clientId, metricName, timePeriod) tuple.

Exact Problems to Fix
"With Context" badge does not display even when DB shows matching insightContexts.userContext.

Likely cause: The frontend isn’t rendering hasContext from server or server isn’t returning it correctly.

Requirement:

Backend must compute hasContext = true if insightContexts row exists for (clientId, metricName, timePeriod) and include it in GET response.

Frontend metric-insight-box.tsx must render badge in correct position (next to “Add Context” button) whenever hasContext is true — even after page reload.

Reload restores the original AI insight instead of the version with context.

Likely cause: GET endpoint pulls from aiInsights table but returns pre-context row due to stale query or missing updated record.

Requirement:

Ensure GET logic always prefers latest aiInsights row for (clientId, metricName, timePeriod) when a context exists.

If a regenerated-with-context insight exists, return that one instead of the original pre-context insight.

Verify that regenerate flow overwrites or versions correctly in DB and that GET honors this ordering.

Delete insight doesn’t clear UI or persist delete on reload.

Likely cause: DELETE endpoint works but frontend doesn’t optimistically clear local state, and stale cache reloads the old insight.

Requirement:

Frontend must:

Immediately clear the insight box to empty state after successful delete.

Invalidate QueryKeys.aiInsights(clientId, canonicalPeriod) so that refetch returns no insight.

Backend must:

Confirm transactional delete removes all matching (clientId, metricName, timePeriod) rows from both aiInsights and insightContexts.

Return { ok: true, deleted: { insights: n, contexts: m } } where both counts > 0 if deletion occurred.

No partial deletes allowed — must be atomic.

Step-by-Step Instructions
Backend: GET Endpoint Fix

File: server/routes.ts → AI Insights GET handler.

Use LEFT JOIN on insightContexts to compute hasContext.

Always select the latest aiInsights record for given (clientId, metricName, timePeriod) — if regenerations overwrite, that’s already handled; if versions exist, pick newest createdAt.

Include hasContext boolean in API JSON payload.

Backend: DELETE Endpoint Verification

File: server/routes.ts → DELETE handler.

Ensure deleteInsightAndContextTransactional() WHERE clause includes timePeriod.

Log deletion counts — confirm both insights and contexts deleted for the tuple.

Frontend: Badge Rendering Fix

File: client/src/components/metric-insight-box.tsx

Ensure component reads hasContext from server response and re-renders badge inline with “Add Context” button.

On mutation success (adding context), update cached query data to set hasContext: true so UI updates instantly.

Frontend: Reload & Context-Persist Fix

Ensure useQuery for AI Insights calls GET with canonical YYYY-MM period, not “Last Month”.

Ensure component state is fully derived from query result, not stale props.

Frontend: Delete UI & Cache Fix

On successful DELETE:

Optimistically clear insight from local state.

Call queryClient.invalidateQueries(QueryKeys.aiInsights(clientId, canonicalPeriod)).

Ensure empty state renders when query result has no insight.

Verification Steps
Add context → reload page → badge appears next to “Add Context” button → regenerated-with-context insight is shown.

Delete insight → UI immediately clears → reload page → no insight returns.

Inspect DB manually:

sql
Copy
Edit
SELECT * FROM aiInsights WHERE clientId = 'demo-client-id' AND timePeriod = '2025-07';
SELECT * FROM insightContexts WHERE clientId = 'demo-client-id' AND timePeriod = '2025-07';
Both should be empty after delete.

Safeguards
Do not alter unrelated routes or components.

Do not remove canonical YYYY-MM normalization.

Keep transactional deletes atomic.

Preserve authentication middleware on all routes.

Preserve query key patterns.