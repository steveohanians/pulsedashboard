
(a) fix the missing “With Context” badge, (b) makes delete truly persistent, and (c) lock in month‑pinned persistence until next month. 



---



# Replit AI Prompt — Fix AI‑Insights Badge, Deletion Persistence, and Month‑Pinned Behavior



## Context (read first)



* **Frontend insight UIs** live in `client/src/components/metric-insight-box.tsx` and `client/src/components/ai-insights.tsx`. These render metric insight text, the “Add context” modal, the **With Context** badge, and “Delete insight”. They use React Query keys alongside the main dashboard query. See Frontend Map for components and query patterns.

* **Backend** routes are centrally registered in `server/routes.ts`; storage is abstracted via `server/storage.ts` hitting tables **aiInsights** and **insightContexts** (Drizzle).

* **Schema**:



  * `aiInsights(clientId, metricName, timePeriod, contextText, insightText, recommendationText, status, createdAt)`

  * `insightContexts(clientId, metricName, userContext, createdAt, updatedAt)`

    These are the sources of truth for whether context exists and for persistence per month.

* **Dashboard + insights queries**: the dashboard query is already non‑cached (`staleTime: 0`, `gcTime: 0`) and uses time‑period mapping; mirror this approach for insights and ensure consistent, canonical `YYYY-MM` month keys to avoid “Last Month” vs `YYYY‑MM` drift.



## Objective



Fix three issues:



1. **“With Context” badge does not appear on reload** even though context exists in DB.

2. **Delete Insight** clears UI but **rows reappear after reload** (DB not actually cleared for that month/metric).

3. **Persistence**: Once an AI insight exists for a **(clientId, metricName, timePeriod)**, keep showing it across app reloads until the next month’s data refresh—no silent re‑generation.



## Guardrails



* **Do not introduce new buttons or flows.** Use existing **Add Context**, **Regenerate**, **Delete Insight** actions.

* **No caching** during this work. Confirm insights queries also run with `staleTime: 0`, `refetchOnMount: 'always'`, `gcTime: 0` while iterating.

* Keep **types** intact and **don’t break** other flows (charts, admin).



## Coverage Checklist (open and review in this order)



1. `client/src/components/metric-insight-box.tsx` — badge render logic, mutations, query keys

2. `client/src/components/ai-insights.tsx` — list+loading logic; ensure it reads month‑pinned records first

3. `client/src/lib/queryClient.ts` — shared query utils/keys; add typed, centralized keys for insights per client+period

4. `server/routes.ts` — canonical **GET/POST/DELETE** insight endpoints and registration

5. `server/storage.ts` — transactional delete and point‑reads; ensure `WHERE` includes **clientId + metricName + timePeriod** on delete and read

6. `shared/schema.ts` — confirm columns/types for `aiInsights` and `insightContexts`

7. `server/services/openai.ts` — generation path; ensure it respects “if record exists for month, don’t regenerate unless explicitly triggered”



## Required Changes



### A) Source‑of‑truth badge logic (frontend)



* In `metric-insight-box.tsx`, compute `hasContext` from **database state on first render**. Do **not** rely on “mutation response” flags.

* `hasContext(clientId, metricName, canonicalPeriod)` should be **true** if either:



  * `aiInsights.contextText` is **non‑empty** for `(clientId, metricName, period)`, **or**

  * there exists a row in `insightContexts` for `(clientId, metricName)` updated **on or before** the insight’s `createdAt` (some installs store userContext separately).

* Ensure the badge is rendered within the insight header near the Add Context trigger (use current design placement). On success, the badge must be visible **after refresh** without user action.



### B) Month‑pinned persistence (backend + frontend)



* Reads: When the UI loads insights for a selected time period, always request by **canonical month** (`YYYY‑MM`), never “Last Month”. Reuse the same month normalization used by the dashboard route (`generateDynamicPeriodMapping`), but return **the canonical month string** to the client and pass it through insight queries.

* Generation: In `server/services/openai.ts`, enforce **idempotent upsert** per `(clientId, metricName, timePeriod)`. If a row exists with `insightText`, **return it**; do **not** regenerate unless user clicked **Regenerate** explicitly.

* Frontend: Ensure the insights query uses `queryKey = ["/api/ai-insights", clientId, canonicalPeriod]` and that mutations **invalidate exactly** that key (and any metric‑scoped subkey you introduce).



### C) Single transactional delete that actually persists



* Implement/verify a single **canonical DELETE** endpoint:



  ```

  DELETE /api/ai-insights/:clientId/:metricName?period=YYYY-MM

  ```



  It must:



  * Start a **DB transaction**.

  * Delete from **aiInsights** where `(clientId, metricName, timePeriod = period)`.

  * Delete associated **insightContexts** for `(clientId, metricName)` (optionally only those relevant to that period if you store period; schema shows no `timePeriod` on insightContexts—clear by metric).

  * Commit, return `{ ok: true, deleted: { insights: n1, contexts: n2 } }`.

* In `storage.ts`, ensure the delete **WHERE** includes **timePeriod** for `aiInsights`, or you’ll leave the month record in place (root cause of reappearing data).

* Frontend `onDelete`: call only this endpoint. On success:



  * `invalidateQueries({ queryKey: ["/api/ai-insights", clientId, canonicalPeriod] })`

  * If the dashboard API inlines insights, also invalidate `["/api/dashboard", clientId, selectedFilters...]` (match existing dashboard query key shape).



### D) No silent regeneration on reload



* In `openai.ts`’s generation path, gate generation by **explicit trigger only**. On normal page load, the **GET** endpoint just reads and returns existing monthly records; it never regenerates. Tie regeneration strictly to the **Regenerate** button (current UI).



### E) Query/Cache flags



* For insights queries, mirror dashboard’s strict freshness during dev:

  `staleTime: 0`, `refetchOnMount: 'always'`, `gcTime: 0`.

* Double‑check any server‑side cache (performance cache); ensure insights endpoints **do not** cache while we iterate.



## Implementation Steps (do in order)



1. **Normalize period**: Create a shared util to convert UI value to canonical `YYYY‑MM` and use it everywhere insights are called (client + server).

2. **Backend GET** `/api/ai-insights/:clientId?period=YYYY‑MM` returns insight rows for that month, plus a boolean `hasContext` computed server‑side (contextText present OR insightContexts row exists).

3. **Backend DELETE** transactional delete as specified above (include affected counts).

4. **Frontend**:



   * Switch badge logic to render off `hasContext` from GET response.

   * Ensure **Delete** only calls the new DELETE route and invalidates exact keys.

   * Ensure **Regenerate** calls the explicit regenerate endpoint and, on success, re‑reads and updates `hasContext`.

5. **Prevent silent regeneration**: In `openai.ts`, short‑circuit if a record exists for `(clientId, metricName, period)` unless `force=true` from Regenerate.



## Success Criteria (acceptance tests)



* **Badge**:



  * Given an existing context in DB, refresh the app → **With Context** is visible immediately (no interactions).

* **Delete**:



  * Click **Delete Insight** for a metric. The server returns `{ ok: true, deleted: { insights: ≥1, contexts: ≥0 } }`. Refresh the page → the deleted insight does **not** reappear for that month.

* **Persistence**:



  * After generating an insight for `(clientId, metricName, 2025‑07)`, multiple reloads show the **same** text. Only **Regenerate** changes it. Next month (e.g., `2025‑08`) can create a new row; the previous month stays intact.

* **No caching artifacts**:



  * Toggling quickly between routes never shows stale badge state.



## Verifications (run these in the shell; adjust PORT if needed)



```bash

# 0) Establish canonical period env var for test

MONTH=$(date -u +"%Y-%m")



# 1) Read insights (should show hasContext: true if you’ve added context)

curl -s "http://localhost:5000/api/ai-insights/demo-client-id?period=$MONTH" | jq



# 2) Delete a specific metric insight for this month

curl -s -X DELETE "http://localhost:5000/api/ai-insights/demo-client-id/Session%20Duration?period=$MONTH" | jq



# 3) Re-read (should be missing)

curl -s "http://localhost:5000/api/ai-insights/demo-client-id?period=$MONTH" | jq



# 4) Regenerate explicitly (should recreate; endpoint may be POST /regenerate)

curl -s -X POST "http://localhost:5000/api/ai-insights/demo-client-id/Session%20Duration/regenerate?period=$MONTH" | jq

```



Also confirm dashboard query invalidation if dashboard embeds insights:



* Dashboard query key follows `["/api/dashboard/${clientId}", period, businessSize, industryVertical]` style with freshness flags; match and invalidate accordingly.



## Red‑Flag Checks (fix if found)



* **Time period drift**: any place using “Last Month” as a literal must be normalized to `YYYY‑MM` for reads/writes/caches.

* **Delete WHERE** missing `timePeriod`: will leave rows behind → insights “reappear” on reload.

* **Badge state derived from mutation only**: switch to server truth on first render.

* **Silent generation on GET**: remove—must only occur on explicit regenerate.

* **Query keys not centralized**: define `QueryKeys.aiInsights(clientId, period)` & use consistently.



---



### Please show:



* Diffs for the files in the Coverage Checklist.

* Logs from the 4 curl checks above (redact keys).

* A short note confirming `hasContext` now renders on first load and that delete stays deleted after refresh.



**References:** Backend routes/storage and services, frontend components and query patterns, schema tables for aiInsights/insightContexts, dashboard query freshness & time‑period mapping.


No file chosenNo file chosen
