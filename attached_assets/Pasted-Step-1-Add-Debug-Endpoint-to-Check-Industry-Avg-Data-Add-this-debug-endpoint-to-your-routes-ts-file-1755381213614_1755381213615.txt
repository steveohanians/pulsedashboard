Step 1: Add Debug Endpoint to Check Industry_Avg Data
Add this debug endpoint to your routes.ts file. Place it near your other debug endpoints (around where you have /api/debug/check-industry-avg):
typescript// Debug endpoint to check Industry_Avg data for all periods
app.get('/api/debug/industry-avg-analysis', requireAuth, async (req, res) => {
  try {
    // Import what we need
    const { db } = await import('./db');
    const { metrics } = await import('@shared/schema');
    const { eq, and, sql, desc } = await import('drizzle-orm');
    
    // Get ALL Industry_Avg metrics
    const industryAvgMetrics = await db
      .select({
        metricName: metrics.metricName,
        timePeriod: metrics.timePeriod,
        value: metrics.value,
        channel: metrics.channel,
        createdAt: metrics.createdAt
      })
      .from(metrics)
      .where(eq(metrics.sourceType, 'Industry_Avg'))
      .orderBy(desc(metrics.timePeriod));
    
    // Get unique periods
    const uniquePeriods = [...new Set(industryAvgMetrics.map(m => m.timePeriod))].sort();
    
    // Core metrics we expect
    const coreMetrics = ['Bounce Rate', 'Session Duration', 'Pages per Session', 'Sessions per User'];
    
    // Build analysis by period
    const periodAnalysis = uniquePeriods.map(period => {
      const periodMetrics = industryAvgMetrics.filter(m => m.timePeriod === period);
      const metricsInPeriod = [...new Set(periodMetrics.map(m => m.metricName))];
      
      return {
        period,
        totalMetrics: periodMetrics.length,
        hasAllCoreMetrics: coreMetrics.every(cm => metricsInPeriod.includes(cm)),
        missingCoreMetrics: coreMetrics.filter(cm => !metricsInPeriod.includes(cm)),
        presentMetrics: metricsInPeriod,
        samples: periodMetrics.slice(0, 2).map(m => ({
          metric: m.metricName,
          value: m.value,
          channel: m.channel
        }))
      };
    });
    
    // Check most recent data
    const mostRecentPeriod = uniquePeriods[uniquePeriods.length - 1] || 'none';
    const oldestPeriod = uniquePeriods[0] || 'none';
    
    res.json({
      summary: {
        totalIndustryAvgMetrics: industryAvgMetrics.length,
        uniquePeriods: uniquePeriods.length,
        periodsWithData: uniquePeriods,
        mostRecentPeriod,
        oldestPeriod,
        currentMonth: new Date().toISOString().slice(0, 7)
      },
      problemPeriods: periodAnalysis.filter(p => !p.hasAllCoreMetrics),
      allPeriodAnalysis: periodAnalysis,
      coreMetricsExpected: coreMetrics
    });
    
  } catch (error) {
    console.error('Industry_Avg analysis error:', error);
    res.status(500).json({ 
      error: error instanceof Error ? error.message : 'Analysis failed',
      stack: error instanceof Error ? error.stack : undefined
    });
  }
});
Replit considerations:

I've used dynamic imports for database modules to avoid any circular dependency issues
Added comprehensive error handling with stack traces
Used defensive programming with fallbacks ('none' for periods)
No complex joins or subqueries that might timeout

Once you add this endpoint, test it by going to:
/api/debug/industry-avg-analysis
Share the JSON response with me, and we'll see exactly what's missing and move to Step 2.