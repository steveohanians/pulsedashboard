Here's a comprehensive prompt to fix the brand story extraction logic:

## Prompt for Replit:

"Fix the brand story content extraction to capture the actual brand positioning and value propositions. The current code is missing critical content because it's looking in the wrong places with overly specific selectors. Here are the requirements:

### 1. Expand Section Detection Beyond "About"
Most modern sites don't use literal 'about' classes. Add more flexible selectors:
```javascript
const aboutSelectors = [
  // Existing selectors...
  '[class*="intro"]', // Many sites use "intro" for brand story
  '[class*="value"]',
  '[class*="approach"]',
  '[class*="services"]',
  '[class*="what-we-do"]',
  '[class*="why-we"]',
  '[class*="difference"]',
  'section:nth-of-type(2)', // Often the second section
  'section:nth-of-type(3)', // Or third after hero
  '.container h2 + p', // Heading-paragraph patterns
  '[class*="content"] h2 + p'
];
```

### 2. Look for Value Proposition Patterns
Brand story isn't just in "about" sections - it's often in value props:
```javascript
// Look for patterns that indicate brand differentiation
const valuePatterns = [
  /we (help|provide|deliver|create|build|offer)/i,
  /our (approach|mission|goal|vision|commitment)/i,
  /years of experience/i,
  /trusted by/i,
  /working with/i,
  /specializ(e|ing) in/i,
  /focus(ed)? on/i,
  /dedicated to/i
];

// Find paragraphs containing these patterns
$('p, h2, h3, h4, li').each((_, el) => {
  const text = $(el).text().trim();
  if (valuePatterns.some(pattern => pattern.test(text)) && 
      text.length > 40 && text.length < 500) {
    contentParts.push(text);
  }
});
```

### 3. Extract Structured Content Lists
Many sites present their story as bullet points or features:
```javascript
// Look for lists that contain value props
$('ul, ol').each((_, list) => {
  const $list = $(list);
  // Check if this list is likely content (not navigation)
  if (!$list.closest('nav, header, footer').length) {
    const items = $list.find('li').slice(0, 6);
    let listContent = [];
    
    items.each((_, li) => {
      const text = $(li).text().trim();
      if (text.length > 20 && text.length < 200 && 
          !text.match(/^(home|about|contact|blog|careers|privacy)/i)) {
        listContent.push(text);
      }
    });
    
    if (listContent.length >= 3) {
      contentParts.push(listContent.join('. '));
    }
  }
});
```

### 4. Smart Header + Content Pairing
Look for heading-content relationships more intelligently:
```javascript
// Find all meaningful headings
$('h2, h3, h4').each((_, heading) => {
  const $heading = $(heading);
  const headingText = $heading.text().trim();
  
  // Skip navigation/footer headings
  if ($heading.closest('nav, header, footer').length) return;
  
  // Look for brand-relevant headings
  const relevantPatterns = [
    /who we|what we|why we|how we/i,
    /our (story|mission|approach|values|team|expertise)/i,
    /about|story|mission|vision/i,
    /services|solutions|capabilities/i,
    /difference|different|unique|why choose/i
  ];
  
  if (relevantPatterns.some(p => p.test(headingText))) {
    // Get next siblings until next heading
    let content = [];
    let current = $heading.next();
    
    while (current.length && !current.is('h1, h2, h3, h4')) {
      if (current.is('p, ul, ol, blockquote')) {
        content.push(current.text().trim());
      }
      current = current.next();
    }
    
    if (content.length > 0) {
      contentParts.push(`${headingText}: ${content.join(' ')}`);
    }
  }
});
```

### 5. Extract from Feature/Service Cards
Modern sites often use cards or grid layouts:
```javascript
// Look for card-like structures
const cardSelectors = [
  '[class*="card"]',
  '[class*="feature"]',
  '[class*="service"]',
  '[class*="grid"] > div',
  '[class*="col-"] > div'
];

cardSelectors.forEach(selector => {
  $(selector).slice(0, 6).each((_, card) => {
    const $card = $(card);
    const title = $card.find('h3, h4, h5').first().text().trim();
    const desc = $card.find('p').first().text().trim();
    
    if (title && desc && desc.length > 30) {
      contentParts.push(`${title}: ${desc}`);
    }
  });
});
```

### 6. Improved Fallback Strategy
If primary methods fail, use smarter content detection:
```javascript
if (contentParts.length < 3) {
  // Get main content area
  const mainContent = $('main, [role="main"], #content, .content').first();
  
  if (mainContent.length) {
    // Get all text nodes from main content
    mainContent.find('h2, h3, p').slice(0, 10).each((_, el) => {
      const $el = $(el);
      const text = $el.text().trim();
      
      // Score the text for relevance
      let score = 0;
      
      // Positive indicators
      if (text.length > 50 && text.length < 300) score++;
      if (/we|our|us/i.test(text)) score++;
      if (/help|provide|deliver|solution|service/i.test(text)) score++;
      if (/year|experience|expert|leader/i.test(text)) score++;
      
      // Negative indicators
      if (/cookie|privacy|copyright|Â©/i.test(text)) score -= 2;
      if ($el.closest('aside, .sidebar').length) score--;
      
      if (score > 0) {
        contentParts.push(text);
      }
    });
  }
}
```

### 7. Deduplication and Assembly
Clean and assemble the content intelligently:
```javascript
// Remove duplicates and clean up
const cleanedParts = contentParts
  .filter((text, index, self) => {
    // Remove exact duplicates
    if (self.indexOf(text) !== index) return false;
    
    // Remove if it's a substring of another part
    const isSubstring = self.some((other, otherIndex) => 
      otherIndex !== index && 
      other.includes(text) && 
      other.length > text.length
    );
    
    return !isSubstring;
  })
  .map(text => text.replace(/\s+/g, ' ').trim())
  .filter(text => text.length > 30); // Minimum length

// Prioritize quality content
cleanedParts.sort((a, b) => {
  // Prioritize content with "we/our" language
  const aScore = (a.match(/\b(we|our|us)\b/gi) || []).length;
  const bScore = (b.match(/\b(we|our|us)\b/gi) || []).length;
  return bScore - aScore;
});

// Take best content up to limit
storyContent = cleanedParts.slice(0, 10).join(' ').substring(0, 2500);

// If still too little, expand search
if (storyContent.length < 300) {
  const additionalContent = $('section p').slice(0, 8)
    .map((_, el) => $(el).text().trim())
    .get()
    .filter(text => text.length > 50 && text.length < 400)
    .join(' ');
  
  storyContent = (storyContent + ' ' + additionalContent).substring(0, 2500);
}
```

This approach will capture brand story content from various modern webpage structures by looking for patterns and context rather than specific selectors, prioritizing quality content over quantity, and having multiple fallback strategies."