You are continuing a BEHAVIOR-PRESERVING deep cleanup across the repository.

Absolute guardrails
- No feature changes. No public API/DB schema changes. No new runtime dependencies without approval.
- If a proposed change risks behavior or public contracts, STOP and ask.
- Every step must be reversible and land with a green build.

Goals (in order)
1) Dependency hygiene: remove dead code, collapse near-duplicate helpers, eliminate circular dependencies, reduce cross-module imports via internal facades.
2) Contracts & types: strengthen types/interfaces, add missing null/edge handling, add consumer-driven contract tests for inter-module boundaries.
3) Error & logging consistency: standardize error classes, add structured logging at boundaries (I/O, network, DB), no log noise.
4) Config & constants: centralize feature flags/config; replace ad-hoc env access with a typed config module.
5) Performance hygiene: only mechanical micro-improvements with MEASUREMENT (before/after). No speculative changes.
6) API boundary hardening: add lightweight request/response validators (compile-time if possible), keep behavior identical.

Scope & safety
- Cross-module refactors allowed if they preserve public behavior.
- Update all imports atomically with codemods/AST-aware edits (no regex mass replaces).
- After each step: run static checks, tests, and a smoke run of the app.
- If any check fails, auto-revert that step and propose a safer alternative.

Workflow
1) Produce a short plan (3–6 steps) covering just the next cross-module pass (e.g., dependency hygiene + config centralization).
2) For STEP 1 ONLY: show the unified DIFF and one-line rationale per hunk.
3) Run verification: type check, linter, tests, and import graph scan (report cycles/degree).
4) If green, proceed to STEP 2; otherwise revert and revise.
5) After the plan completes, STOP and ask before starting a new cross-module plan.

Verification commands (replace with project specifics)
- Type check: run the project type checker (e.g., `tsc -noEmit` or `mypy .`)
- Lint/format: `eslint .` or `ruff .` with autofix limited to non-semantic changes
- Tests: run the full test suite with coverage (e.g., `npm test --silent` / `pytest -q`)
- Import graph & dead code: run the repo’s dependency/unused detector if available; otherwise provide a generated report

Output per step
- Summary: one sentence
- Diff: fenced patch
- Verification: checks run + results (type, lint, tests, import graph)
- Risk: what could regress and why (1–2 lines)
- Next step: one sentence

Stop conditions
- Any failing test/type error
- Any public API/DB surface change required
- Any measurable performance regression
- Any uncertainty about behavior equivalence

Continuation
- If time/context runs out, PAUSE at a safe checkpoint. I will paste this prompt again to resume with the next planned step.
