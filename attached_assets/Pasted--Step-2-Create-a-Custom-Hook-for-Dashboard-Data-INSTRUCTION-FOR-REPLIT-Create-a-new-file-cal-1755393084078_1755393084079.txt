# Step 2: Create a Custom Hook for Dashboard Data

**INSTRUCTION FOR REPLIT:**
Create a new file called `useDashboardData.ts` in the `/client/src/hooks/` directory. This custom hook will handle ALL data fetching and processing for the dashboard, using our new UnifiedDataService. This will dramatically simplify the dashboard.tsx file.

**IMPORTANT RULES:**
1. DO NOT modify dashboard.tsx yet (we'll do that in the next step)
2. DO NOT delete any existing hooks
3. Keep the same query key structure for caching
4. Use the existing apiRequest function
5. Handle loading, error, and data states properly

**CREATE THIS EXACT FILE:**

```typescript
/**
 * Custom hook for dashboard data fetching and processing
 * Centralizes all dashboard data logic in one place
 */

import { useState, useMemo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { QueryKeys } from '@/lib/queryKeys';
import { apiRequest } from '@/lib/queryClient';
import { unifiedDataService } from '@/services/unifiedDataService';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { APIError } from '@/lib/queryClient';

interface DashboardHookOptions {
  timePeriod: string;
  businessSize?: string;
  industryVertical?: string;
}

interface DashboardHookReturn {
  // Data
  data: any;
  processedData: any;
  isLoading: boolean;
  error: APIError | null;
  
  // Insights
  insights: any;
  insightsLoading: boolean;
  insightsError: any;
  
  // Competitors
  competitors: any[];
  deleteCompetitor: (id: string) => void;
  deletingCompetitorId: string | null;
  
  // Actions
  refetch: () => void;
  refetchInsights: () => void;
  clearInsights: () => void;
  
  // Metadata
  client: any;
  metrics: any[];
  periods: any;
  dataQuality: any;
}

export function useDashboardData({
  timePeriod = 'Last Month',
  businessSize = 'All',
  industryVertical = 'All'
}: DashboardHookOptions): DashboardHookReturn {
  const { user } = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  const [deletingCompetitorId, setDeletingCompetitorId] = useState<string | null>(null);
  const [dashboardError, setDashboardError] = useState<APIError | null>(null);

  // Compute effective time period for custom date ranges
  const effectiveTimePeriod = timePeriod;

  // Main dashboard data query
  const dashboardQuery = useQuery<any>({
    queryKey: QueryKeys.dashboard(
      user?.clientId || '',
      effectiveTimePeriod
    ),
    queryFn: async () => {
      try {
        const result = await apiRequest(
          'GET',
          `/api/dashboard/${user?.clientId}?timePeriod=${encodeURIComponent(effectiveTimePeriod)}&businessSize=${encodeURIComponent(businessSize)}&industryVertical=${encodeURIComponent(industryVertical)}`
        );
        return result;
      } catch (error) {
        if (error instanceof APIError) {
          setDashboardError(error);
        }
        throw error;
      }
    },
    enabled: !!user?.clientId,
    staleTime: 0,
    refetchOnMount: 'always',
    gcTime: 0,
    refetchOnReconnect: true,
    refetchOnWindowFocus: true,
  });

  // Process dashboard data using UnifiedDataService
  const processedData = useMemo(() => {
    if (!dashboardQuery.data) return null;
    
    // Use the unified service to process ALL data
    return unifiedDataService.processDashboardData(
      dashboardQuery.data,
      effectiveTimePeriod
    );
  }, [dashboardQuery.data, effectiveTimePeriod]);

  // AI Insights query
  const insightsQuery = useQuery({
    queryKey: QueryKeys.aiInsights(
      user?.clientId || '',
      effectiveTimePeriod
    ),
    queryFn: async () => {
      try {
        const result = await apiRequest(
          'GET',
          `/api/ai-insights/${user?.clientId}?timePeriod=${encodeURIComponent(effectiveTimePeriod)}`
        );
        return result;
      } catch (error) {
        if (error instanceof APIError) {
          console.error('AI Insights error:', error);
        }
        throw error;
      }
    },
    enabled: !!user?.clientId,
    staleTime: 60 * 1000, // 1 minute
    gcTime: 5 * 60 * 1000, // 5 minutes
    retry: 1,
  });

  // Delete competitor mutation
  const deleteCompetitorMutation = useMutation({
    mutationFn: async (competitorId: string) => {
      const response = await fetch(`/api/competitors/${competitorId}`, {
        method: 'DELETE',
        credentials: 'include',
      });
      if (!response.ok) {
        throw new Error(`Failed to delete competitor: ${response.status}`);
      }
      const text = await response.text();
      return text ? JSON.parse(text) : { success: true };
    },
    onSuccess: () => {
      // Invalidate relevant queries
      queryClient.invalidateQueries({
        queryKey: QueryKeys.dashboard(user?.clientId || '', effectiveTimePeriod)
      });
      queryClient.invalidateQueries({
        queryKey: QueryKeys.aiInsights(user?.clientId || '', effectiveTimePeriod)
      });
      
      // Refetch data
      dashboardQuery.refetch();
      insightsQuery.refetch();
      
      setDeletingCompetitorId(null);
      
      toast({
        title: 'Competitor removed',
        description: 'The competitor has been successfully removed.',
        duration: 3000,
      });
    },
    onError: (error) => {
      setDeletingCompetitorId(null);
      toast({
        title: 'Failed to remove competitor',
        description: error.message,
        variant: 'destructive',
        duration: 3000,
      });
    },
  });

  // Clear insights mutation
  const clearInsightsMutation = useMutation({
    mutationFn: async () => {
      const response = await fetch('/api/debug/clear-all-insights', {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
      }

      return response.json();
    },
    onSuccess: () => {
      // Clear localStorage
      try {
        localStorage.removeItem('pulse_dashboard_insights');
      } catch (error) {
        console.warn('Failed to clear localStorage:', error);
      }
      
      // Invalidate queries
      queryClient.invalidateQueries({
        queryKey: QueryKeys.dashboard(user?.clientId || '', effectiveTimePeriod)
      });
      queryClient.invalidateQueries({
        queryKey: QueryKeys.aiInsights(user?.clientId || '', effectiveTimePeriod)
      });
      queryClient.invalidateQueries({
        queryKey: QueryKeys.metricInsights(user?.clientId || '')
      });
      
      // Refetch
      dashboardQuery.refetch();
      insightsQuery.refetch();
      
      toast({
        title: 'Insights cleared',
        description: 'All AI insights have been cleared successfully.',
        duration: 3000,
      });
    },
    onError: (error) => {
      toast({
        title: 'Failed to clear insights',
        description: error.message,
        variant: 'destructive',
        duration: 3000,
      });
    },
  });

  // Helper function to delete competitor
  const deleteCompetitor = (competitorId: string) => {
    setDeletingCompetitorId(competitorId);
    deleteCompetitorMutation.mutate(competitorId);
  };

  // Extract commonly used data
  const client = dashboardQuery.data?.client;
  const competitors = dashboardQuery.data?.competitors || [];
  const metrics = dashboardQuery.data?.metrics || [];
  const insights = insightsQuery.data?.insights || [];

  return {
    // Raw and processed data
    data: dashboardQuery.data,
    processedData,
    isLoading: dashboardQuery.isLoading || dashboardQuery.isRefetching,
    error: dashboardError,
    
    // Insights
    insights,
    insightsLoading: insightsQuery.isLoading,
    insightsError: insightsQuery.error,
    
    // Competitors
    competitors,
    deleteCompetitor,
    deletingCompetitorId,
    
    // Actions
    refetch: () => {
      dashboardQuery.refetch();
      insightsQuery.refetch();
    },
    refetchInsights: () => insightsQuery.refetch(),
    clearInsights: () => clearInsightsMutation.mutate(),
    
    // Metadata
    client,
    metrics,
    periods: processedData?.periods,
    dataQuality: processedData?.dataQuality,
  };
}

/**
 * Hook for dashboard filters data
 */
export function useDashboardFilters() {
  const filtersQuery = useQuery<{
    businessSizes: string[];
    industryVerticals: string[];
    timePeriods: string[];
  }>({
    queryKey: QueryKeys.filters(),
    queryFn: async () => {
      return apiRequest('GET', '/api/filters');
    },
  });

  return {
    businessSizes: filtersQuery.data?.businessSizes || [],
    industryVerticals: filtersQuery.data?.industryVerticals || [],
    timePeriods: filtersQuery.data?.timePeriods || [],
    isLoading: filtersQuery.isLoading,
  };
}
```

**AFTER CREATING THIS FILE:**
Tell me "Hook created successfully" and I'll give you the next step to dramatically simplify the dashboard.tsx file using this hook.