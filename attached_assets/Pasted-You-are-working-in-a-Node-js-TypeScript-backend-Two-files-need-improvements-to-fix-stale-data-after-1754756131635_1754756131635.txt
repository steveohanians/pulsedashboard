You are working in a Node.js/TypeScript backend. Two files need improvements to fix stale data after “cache clear” and follow caching best practices.

Target files:
	1.	server/services/smartGA4DataFetcher.ts
	2.	server/routes/cleanupAndFetchRoute.ts

Goals:
	•	Add a force?: boolean parameter to the fetcher that bypasses cached reads and always refreshes data when set.
	•	Implement per-period locking to prevent concurrent fetches for the same GA4 key.
	•	Record lastFetchedAt and source metadata on writes.
	•	In the cleanup route, set HTTP headers to make it fully non-cacheable at every layer (Cache-Control: no-store etc.).
	•	Add a concurrency guard so only one cleanup runs at a time.
	•	Ensure cleanup calls the fetcher with { force: true }.
	•	Avoid deleting data for all clients; scope deletes to the provided clientId.

Implementation details:
In server/services/smartGA4DataFetcher.ts:
	•	Update the main exported function signature to accept force?: boolean.
	•	Before fetching each period, acquire a lock with TTL (in-memory or Redis if available) using a helper function you define at the top of the file.
	•	When force is true, skip any cached read logic and always hit the GA4 API before writing.
	•	On writes, store metadata { lastFetchedAt: new Date().toISOString(), source: ‘ga4’ }.

In server/routes/cleanupAndFetchRoute.ts:
	•	At the start of the route, set:
res.setHeader(‘Cache-Control’, ‘no-store, no-cache, must-revalidate, max-age=0’);
res.setHeader(‘Pragma’, ‘no-cache’);
res.setHeader(‘Expires’, ‘0’);
res.setHeader(‘Surrogate-Control’, ‘no-store’);
	•	Add a lock so if a cleanup is already in progress, respond with HTTP 409 and JSON { ok:false, message:‘Cleanup already in progress’ }.
	•	Clear only synthetic/derived caches for the given clientId, then call smartGA4DataFetcher({ clientId, force: true }).
	•	Return a JSON object summarizing which periods were refetched, with their new lastFetchedAt.

Constraints:
	•	Do not rename functions or change public route paths.
	•	Keep all new logic self-contained in these two files (locks can be inline in each file).
	•	Use async/await and keep TypeScript types correct.
	•	Make no breaking changes for existing callers that don’t use the force flag.

Deliverable:
	•	Updated content of both files, fully implementing the above behavior, with clear comments marking new/modified code.
	•	Keep the rest of the file logic intact.