You're absolutely right! Let me compare the original code to what we have now. 

## The KEY DIFFERENCE I Found:

In the **original `dashboard.tsx`**, there were two separate functions:
1. `processTrafficChannelData()` - which called `trafficChannelService.processChannels()`
2. `processDeviceDistributionData()` - which called `deviceDistributionService.processDevices()`

These functions were passing the FULL dashboard data object, including all the raw metrics, competitors, client info, etc.

In our **new simplified version**, we're just using:
- `processedData?.trafficChannels` 
- `processedData?.deviceDistribution`

But here's the problem: The `unifiedDataService` isn't getting the same data that the original services were getting. Specifically:

1. **Original code passed**: `dashboardData`, `metrics`, `competitors`, `client`, `timeSeriesData`
2. **New code passes**: Only `dashboardData` and `timePeriod`

## The Fix:

The issue is that `dashboardData.metrics` might not contain all the device distribution data, especially for Industry_Avg and Competitors. The original services were doing additional processing to handle missing data.

**INSTRUCTION FOR REPLIT:**
Fix the device distribution by ensuring the unifiedDataService gets ALL the data it needs, including the proper competitor and industry benchmark metrics.

**MODIFY `/client/src/services/unifiedDataService.ts` - UPDATE THE `processDashboardData` METHOD:**

**FIND THIS SECTION (around line 70-90):**
```typescript
    // Step 3: Process traffic channels
    const trafficChannels = this.processTrafficChannels(
      dashboardData.metrics || [],
      dashboardData.competitors || [],
      dashboardData.client,
      periods
    );
    
    // Step 4: Process device distribution
    const deviceDistribution = this.processDeviceDistribution(
      dashboardData.metrics || [],
      dashboardData.competitors || [],
      dashboardData.client,
      periods
    );
```

**REPLACE WITH:**
```typescript
    // Step 3: Process traffic channels - pass ALL data like original
    const trafficChannels = this.processTrafficChannels(
      dashboardData.metrics || [],
      dashboardData.competitors || [],
      dashboardData.client,
      periods,
      dashboardData.trafficChannelMetrics || [],
      dashboardData.timeSeriesData
    );
    
    // Step 4: Process device distribution - include averagedMetrics
    const deviceDistribution = this.processDeviceDistribution(
      dashboardData.metrics || [],
      dashboardData.competitors || [],
      dashboardData.client,
      periods,
      dashboardData.averagedMetrics
    );
```

**THEN UPDATE THE `processTrafficChannels` METHOD SIGNATURE:**
```typescript
  private processTrafficChannels(
    metrics: DashboardMetric[],
    competitors: Array<{ id: string; domain: string }>,
    client: { name?: string } | undefined,
    periods: DataPeriods,
    trafficChannelMetrics?: any[],
    timeSeriesData?: any
  ): any[] {
    // Use trafficChannelMetrics if available (like original)
    const trafficMetrics = trafficChannelMetrics && trafficChannelMetrics.length > 0 
      ? trafficChannelMetrics 
      : metrics.filter(m => m.metricName === "Traffic Channels");
```

**AND UPDATE THE `processDeviceDistribution` METHOD TO CHECK AVERAGEDMETRICS:**
```typescript
  private processDeviceDistribution(
    metrics: DashboardMetric[],
    competitors: Array<{ id: string; domain: string }>,
    client: { name?: string } | undefined,
    periods: DataPeriods,
    averagedMetrics?: any
  ): any[] {
    const deviceMetrics = metrics.filter(m => m.metricName === "Device Distribution");
    const result: any[] = [];

    // ... existing client and CD processing ...

    // Process Industry Average - CHECK AVERAGEDMETRICS FIRST
    if (averagedMetrics && averagedMetrics["Device Distribution"] && averagedMetrics["Device Distribution"]["Industry_Avg"]) {
      // Use pre-calculated industry average
      const industryValue = averagedMetrics["Device Distribution"]["Industry_Avg"];
      const devices = this.parseDeviceValue(industryValue);
      if (devices.length > 0) {
        result.push({
          sourceType: "Industry_Avg",
          label: "Industry Avg",
          devices: devices
        });
      }
    } else {
      // Fallback to existing logic
      const industryDevices = this.aggregateDevicesBySource(
        deviceMetrics.filter(m => m.sourceType === "Industry_Avg" || m.sourceType === "industry_avg" || m.sourceType === "Industry")
      );
      if (industryDevices.length > 0) {
        result.push({
          sourceType: "Industry_Avg",
          label: "Industry Avg",
          devices: industryDevices
        });
      }
    }

    // For competitors, also check if data exists in metrics with proper competitorId
    competitors.forEach(competitor => {
      // First try to find in regular metrics
      const competitorMetrics = deviceMetrics.filter(m => 
        m.sourceType === "Competitor" && 
        m.competitorId === competitor.id
      );
      
      if (competitorMetrics.length > 0) {
        const competitorDevices = this.aggregateDevicesBySource(competitorMetrics);
        if (competitorDevices.length > 0) {
          result.push({
            sourceType: `Competitor_${competitor.id}`,
            label: this.cleanDomainName(competitor.domain),
            devices: competitorDevices
          });
        }
      } else {
        // If no data found, create default distribution
        // This ensures competitors show up even if data is missing
        result.push({
          sourceType: `Competitor_${competitor.id}`,
          label: this.cleanDomainName(competitor.domain),
          devices: [
            { name: 'Desktop', value: 60, percentage: 60, color: this.getDeviceColor('Desktop') },
            { name: 'Mobile', value: 40, percentage: 40, color: this.getDeviceColor('Mobile') }
          ]
        });
      }
    });
```

This should fix the issue by ensuring the unified service has access to all the data sources that the original services were using, particularly the `averagedMetrics` which likely contains the Industry_Avg device distribution data.