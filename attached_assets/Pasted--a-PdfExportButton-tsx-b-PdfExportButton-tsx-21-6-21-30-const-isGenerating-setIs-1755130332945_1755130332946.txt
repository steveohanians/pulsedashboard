--- a/PdfExportButton.tsx
+++ b/PdfExportButton.tsx
@@ -21,6 +21,30 @@
   const [isGenerating, setIsGenerating] = React.useState(false);
 
   // Elements we must ignore during canvas capture (iframes/canvas/video or anything tagged to hide)
   const shouldIgnoreForPdf = (el: Element) => {
     const node = el as HTMLElement;
     const tag = node.tagName;
     if (tag === 'IFRAME' || tag === 'VIDEO' || tag === 'CANVAS') return true;
     return node.hasAttribute('data-pdf-hide') || node.getAttribute('data-pdf-hide') === 'true';
   };
 
+  // Ensure <img> tags wonâ€™t taint canvas: add crossOrigin to in-page images
+  const prepareImagesForCors = (root: HTMLElement) => {
+    const imgs = Array.from(root.querySelectorAll('img'));
+    imgs.forEach((img) => {
+      try {
+        // Donâ€™t stomp on explicit dev settings
+        if (!img.getAttribute('crossorigin')) {
+          img.setAttribute('crossorigin', 'anonymous');
+        }
+        // Optional: reduces Referer-based hotlinking/CORS rejections in some setups
+        if (!img.getAttribute('referrerpolicy')) {
+          img.setAttribute('referrerpolicy', 'no-referrer');
+        }
+      } catch {}
+    });
+  };
+
   // -------- Sandbox-safe download helpers (work inside/outside iframes) --------
   const isEmbedded = () => {
     try {
       return window.self !== window.top;
     } catch {
@@ -83,6 +107,7 @@
   // Slice-based rendering (1400px chunks) to prevent memory crashes
   const captureInSlices = async (element: HTMLElement, html2canvas: any) => {
     const SLICE_HEIGHT = 1400;
     const elementHeight = element.scrollHeight;
     const elementWidth = element.scrollWidth;
     const totalSlices = Math.ceil(elementHeight / SLICE_HEIGHT);
@@ -109,29 +134,56 @@
       const yOffset = i * SLICE_HEIGHT;
       const sliceHeight = Math.min(SLICE_HEIGHT, elementHeight - yOffset);
 
       console.info(`ðŸ” Capturing slice ${i + 1}/${totalSlices} at y=${yOffset}, height=${sliceHeight}`);
 
-      // CORS-safe capture configuration
-      const canvas = await html2canvas(element, {
-        height: sliceHeight,
-        width: elementWidth,
-        ignoreElements: shouldIgnoreForPdf,
-        x: 0,
-        y: yOffset,
-        scrollX: 0,
-        scrollY: -yOffset,
-        backgroundColor: '#ffffff',
-        scale: 1,
-        useCORS: true,
-        allowTaint: false,
-        foreignObjectRendering: false,
-        logging: false,
-        imageTimeout: 15000,
-        removeContainer: true,
-        async: true,
-        windowWidth: elementWidth,
-        windowHeight: sliceHeight
-      });
+      // CORS-safe capture configuration with robust onclone adjustments
+      let canvas: HTMLCanvasElement;
+      try {
+        canvas = await html2canvas(element, {
+          height: sliceHeight,
+          width: elementWidth,
+          ignoreElements: shouldIgnoreForPdf,
+          x: 0,
+          y: yOffset,
+          scrollX: 0,
+          scrollY: -yOffset,
+          backgroundColor: '#ffffff',
+          scale: 1,
+          useCORS: true,
+          allowTaint: false,
+          foreignObjectRendering: false,
+          logging: false,
+          imageTimeout: 15000,
+          removeContainer: true,
+          async: true,
+          windowWidth: elementWidth,
+          windowHeight: sliceHeight,
+          onclone: (doc) => {
+            // Strip risky elements in the clone to avoid runtime errors
+            doc.querySelectorAll('iframe,video,canvas,[data-pdf-hide="true"],[data-pdf-hide]').forEach((n) => n.parentNode?.removeChild(n));
+            // Add crossOrigin/referrerpolicy to images in the clone
+            doc.querySelectorAll('img').forEach((img) => {
+              if (!img.getAttribute('crossorigin')) img.setAttribute('crossorigin', 'anonymous');
+              if (!img.getAttribute('referrerpolicy')) img.setAttribute('referrerpolicy', 'no-referrer');
+            });
+          },
+        });
+      } catch (err) {
+        const msg = (err instanceof Error && err.message) ? err.message : String(err);
+        console.error(`âŒ html2canvas failed on slice ${i + 1}/${totalSlices} at y=${yOffset}:`, msg);
+        throw err; // bubble to outer handler so we donâ€™t hang silently
+      }
 
       canvases.push(canvas);
 
       // Small delay between slices to prevent memory overload
       await new Promise(resolve => setTimeout(resolve, 100));
     }
 
     return canvases;
   };
@@ -167,6 +219,10 @@
       console.info('Target element found, preparing for slice-based capture');
 
       // Asset preflight loading for fonts/images (from working implementation notes)
       if (document.fonts?.ready) {
         await document.fonts.ready;
       }
+
+      // Ensure in-page <img> wonâ€™t taint the canvas
+      prepareImagesForCors(element);
+
       // Ensure all images are loaded
       const images = Array.from(element.querySelectorAll('img'));
       await Promise.all(images.map(img => {
         if (img.complete) return Promise.resolve();
         return new Promise(resolve => {
