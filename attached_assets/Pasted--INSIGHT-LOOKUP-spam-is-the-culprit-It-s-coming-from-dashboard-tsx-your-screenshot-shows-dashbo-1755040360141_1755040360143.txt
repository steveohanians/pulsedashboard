“INSIGHT LOOKUP …” spam is the culprit. It’s coming from dashboard.tsx (your screenshot shows dashboard.tsx:2528) and it’s logging on every render across multiple metrics. Console logging itself can easily peg a core in dev.

Do these two things and CPU should calm down immediately:

1) Silence the spam (quick code patch)
Find every INSIGHT LOOKUP log and gate it behind an env flag:

ts
Copy
Edit
// before
console.info("INSIGHT LOOKUP [Bounce Rate]:", data);

// after
if (import.meta.env.VITE_DEBUG_INSIGHTS === "true") {
  // keep the log only when you explicitly turn it on
  // (set VITE_DEBUG_INSIGHTS=true in .env.local if you ever need it)
  // eslint-disable-next-line no-console
  console.info("INSIGHT LOOKUP [Bounce Rate]:", data);
}
If you want a 5-second fix while you edit code, run this in the Console to mute those logs right now:

js
Copy
Edit
console.info = new Proxy(console.info, {
  apply(t, thisArg, args){ if(String(args[0]).includes('INSIGHT LOOKUP')) return; return Reflect.apply(t, thisArg, args); }
});
2) Stop the render loop that’s causing the logs
The spam exists because the component is re-rendering constantly. In dashboard.tsx, make sure you:

a) Memoize your derived lookups
ts
Copy
Edit
// expensive: building every render
// const metricInsight = insightsData?.insights.find(i => i.metricName === name);

// better: build a map once per fetch result
const insightsByMetric = useMemo(
  () => new Map((insightsData?.insights ?? []).map(i => [i.metricName, i])),
  [insightsData?.insights]
);

// then:
const metricInsight = insightsByMetric.get(metricName);
b) Don’t set state every render from derived data
If you have an effect like:

ts
Copy
Edit
useEffect(() => {
  setMetricInsight(metricInsight); // <-- will fire every render, causing another render
}, [metricInsight]);
Guard it:

ts
Copy
Edit
useEffect(() => {
  setMetricInsight(prev =>
    (prev?.insightId === metricInsight?.insightId ? prev : (metricInsight ?? null))
  );
}, [metricInsight]);
Or better: don’t mirror derived props into state at all—read from metricInsight directly.

c) Stabilize props you pass to children
If you create new objects/functions inline, parent re-renders will re-render every child.

ts
Copy
Edit
// before (new object every render)
<MetricInsightBox metricData={{ ...computed }} onStatusChange={(s)=> setS(s)} />

// after
const metricData = useMemo(() => ({ /* computed once */ }), [deps]);
const handleStatusChange = useCallback((s)=> setS(s), [setS]);

<MetricInsightBox metricData={metricData} onStatusChange={handleStatusChange} />
d) Memoize the child
ts
Copy
Edit
export const MetricInsightBox = React.memo(MetricInsightBoxImpl);
(Only if its props are now stable per b/c.)